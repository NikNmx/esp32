#GPIO12 - D6 - grid binary_sensore "0" - Grid is available (220V), 
#"1" - Grid is absent (0V)
#
#GPIO14 - D5 binary conf pin . if = "1" - GPIO12 -D6 is inverted
#grid binary_sensore "0" - Grid is absent (0V), 
#"1" - Grid is available (220V)
#
#GPIO2 - D4 - Internal Led (id="Led1) inverted:true
#GPIO5 - D1 - External Led (id="Led2) inverted:false
substitutions:
  TELEGRAM_BOT_TOKEN: !secret sTELEGRAM_BOT_TOKEN
  chat_id: !secret schat_id
  trigger1: "1"

esphome:
  name: 220gridsensor
  friendly_name: 220gridsensor
  on_boot:
    priority: -100  # -100 is after reboot and settings WIFI + Pins
    then:    #setup some global variables
      - repeat:    #few Led1 blinks afrter reboot
          count: 5
          then:
            - light.turn_on: Led1
            - delay: 100ms
            - light.turn_off: Led1
            - delay: 100ms      
      - delay: 20s # because flashinf is continue during boot process.  
      - logger.log:
          format: "!!!boot_var_flash %i and bootSensor1_grid  %i"
          args: [ 'id(global_var_flashing)', 'id(Binary_sensor_grid_status).state' ]
      - lambda : |-
                  if (id(Binary_sensor_grid_status).state) {
                  id(global_var_flashing) = 1;
                  } else {
                  id(global_var_flashing) = 0;
                  }
      - script.execute: send_rebooted # script steps after reboot

esp8266:
  board: d1_mini
  restore_from_flash: true

# Enable logging
logger:

globals:
#blink couter 
   - id: global_var_int1 #it is for blinking, may be replaced for static lambda variable
     type: int
     restore_value: no
     initial_value: "0"
   - id: global_var_flashing # if == 1 , LED2 is blinking every 1s.
     type: int
     restore_value: no
     initial_value: "1"
              

# Enable API  # Does not use in this configuration.
#api:
#  password: "1234567890"

ota: # maybe used in fallback ap portal. I'm not sure.
  - platform: esphome
    password: "1234567890"

wifi:
  ssid: "esptool"
  password: "1111qQ1111qQ,@,@"

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "ap_buro_grid"
    password: "1111qQ1111qQ,@,@"

captive_portal:

output:
  - platform: gpio #pin D4 for Led1 
    pin: GPIO2  #D4 - internal LED "Heart beating"
    id: led1_output
    inverted: true
               
  - platform: gpio #pin D5 for Led2
    pin: GPIO5
    id: led2_output
    inverted: true           

light: #components for LED's turn ON and OFF
  - platform: binary
    name: "Led1 - 'Heart beating'"
    internal: true #Not shown on Webserver 8080
    id: Led1
    #pin: GPIO2
    output: led1_output
  - platform: binary
    name: "Led2"
    id: Led2
    #pin: GPIO5
    output: led2_output 
    
time:
  - platform: sntp
    on_time:
      - seconds: /1  #every second
        then: 
          - lambda: |-
                      if (id(script1).is_running()) {
                      
                      } else {
                      ESP_LOGI("main", "Heart beating OK!");
                      id(script1).execute();
                      }
                      if (id(global_var_flashing) == 1 ) {
                      id(script2).execute();
                      }

#                      //#if (id(script1_flag) == 0 ) {
#                      //#id(script1).execute();
#                      if (id(global_var_flashing) == 1  ) 
#                      {
#                        if (id(global_var_int1) != 0) 
#                        {
#                          //# global value is 0
#                          id(global_var_int1) = 0;
#                          auto call2 = id(Led2).turn_on();
#                          call2.perform();
#                        } else {
#                           id(global_var_int1) = 1;
#                            auto call2 = id(Led2).turn_off();
#                            call2.perform();
#                        }
#                      } else { 
#                          auto call2 = id(Led2).turn_off();
#                          call2.perform(); 
#                          //uncoment for call script from lambda #id(script1).execute();  
#                      }

http_request:
  useragent: esphome/device
  timeout: 10s
  verify_ssl: false

binary_sensor:
  - platform: gpio
    internal: false
    name: "Pin_D6input_Sensore_grid_absent"
    pin:  #pullup: true - ???? is present on esp8266 ?
      number: GPIO12  #number: GPIO12 - D6
      inverted: false
    id: Binary_sensor_grid_status
    filters:
      delayed_on_off: 10000ms #antibounce
    on_state:
      then:
    on_press: #grid is absent . input pin state == 1 (without inversion)
      then: #may be called send script instead next code
        - http_request.post:
            url: "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
            headers:
              Content-Type: application/json
            json:
              chat_id: ${chat_id}
              text: "Grid is OFF üò†" 
        - lambda: |-
            id(global_var_flashing) = 1;      
    on_release:
      then: #may be called send script instead next code
        - http_request.post:
            url: "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
            headers:
              Content-Type: application/json
            json:
              chat_id: ${chat_id}
              text: "Grid is ON üòÄ"
        - lambda: |-
            id(global_var_flashing) = 0;      
  
script:
  - id: script1  #heart beating 1 per 10 sec
  #  parameters:
  #    delay_ms: int
    mode: single #restart
    then:
      #- lambda : |-
      #             id(script1_flag) = 1;

      - light.turn_on: Led1
      - delay: 20ms
      - light.turn_off: Led1
      - delay: 10s
      - logger.log:
              format: "!!!global_var_flashing %i and global_var_int1 %i and gridsensor %i"
              args: [ 'id(global_var_flashing)', 'id(global_var_int1)', 'id(Binary_sensor_grid_status).state' ]    
      #- lambda : |-
      #             id(script1_flag) = 0;
  - id: script2  #Led2 (Grid is absent) fast blinking 2 times per second.
    mode: restart
    then:
      #- lambda : |-
      #             id(script1_flag) = 1;
      - light.turn_on: Led2
      - delay: 240ms
      - light.turn_off: Led2
      - delay: 240ms
      - light.turn_on: Led2
      - delay: 240ms
      - light.turn_off: Led2
      - delay: 240ms
  - id: send_rebooted #script2 run steps after (on) reboot device 
    then:
      - http_request.post:
          url: "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
          headers:
            Content-Type: application/json
          json:
            chat_id: ${chat_id}
            text: !lambda |-
                    if (id(Binary_sensor_grid_status).state) {
                    id(global_var_flashing) = 1;
                    return "‚ö†Ô∏è Check Device! It is Rebooted!!! Grid is OFFüò†!!!" ;
                    } else {
                    id(global_var_flashing) = 0;
                    return "‚ö†Ô∏è Check Device! It is Rebooted!!! Grid is ONüòÄ!!!" ;
                    }
                   
switch:  #swith "Inversion". May be used in future projects
  - platform: gpio
    pin: GPIO14
    id: inverse
    name: "Switch_Grid_sensore_inversion_pin_outputD5"
    restore_mode: RESTORE_DEFAULT_OFF

web_server: 
  port: 8080
  auth:
    username: admin
    password: 1111qQ1111qQ
